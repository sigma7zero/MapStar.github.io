<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Map Star</title>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>        
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
        
        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");
                    canvas.focus();
                    var startRenderLoop = function (engine, canvas) {
                        
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                                engineFPS = engine.getFps().toFixed();
                            }
                        });
                    }

            
    var engine = null;
    var scene = null;    
    var sceneToRender = null;
    var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
    var createScene = async function () {    
    var scene = new BABYLON.Scene(engine);

    scene.clearColor = new BABYLON.Color3(0, 0, 0).toLinearSpace();

    // Sky sphere
    var skySphere = BABYLON.MeshBuilder.CreateSphere("sky", { diameter: 1024, segments: 32 }, scene);
    skySphere.flipFaces(true);
    skySphere.position.x = 0;
    skySphere.position.y = 0;
    skySphere.position.z = 0;
    skySphere.rotate(BABYLON.Axis.X, BABYLON.Tools.ToRadians(180), BABYLON.Space.LOCAL);
    skySphere.receiveShadows = false;

    // Env sky material
    let skyMat = new BABYLON.StandardMaterial("skyMat", scene);
    
    function setEnvMap(src, mat, blumin, bFaceCull, skyObj){
        var tex = new BABYLON.Texture(src, scene);
        mat.diffuseTexture  = tex;
        mat.specularTexture = tex;
        mat.emissiveTexture = tex;
        mat.useEmissiveAsIllumination = blumin;
        mat.backFaceCulling = bFaceCull;
        skyObj.material = mat;
    };
    
    setEnvMap(
        "https://raw.githubusercontent.com/sigma7zero/MapStar/main/Environments/Columbia.jpg",
        skyMat,
        true,
        false,
        skySphere
    );


    // Cameras  
    // 1  
    var gameCamera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 2, -10), scene);
    gameCamera.setTarget(BABYLON.Vector3.Zero());
    gameCamera.attachControl(canvas, true);
    // 2
    var arcRotateCamera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);
    arcRotateCamera.setPosition(new BABYLON.Vector3(0, 2, -10));

    // Create a light source
    var light = new BABYLON.DirectionalLight("DirectLight1", new BABYLON.Vector3(1, -2, 1), scene);
    light.position = new BABYLON.Vector3(-20, 40, -20);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.6;
    light.diffuse = new BABYLON.Color3(0.83, 0.94, 1);

    // Our built-in 'sphere' shape.
    let sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 2, segments: 32 }, scene);

    // Move the sphere upward 1/2 its height
    sphere.position.y = 1; 

    // Add plane
    let plane = BABYLON.MeshBuilder.CreatePlane("plane", { height: 5, width: 5}, scene);
    plane.rotation.x = BABYLON.Tools.ToRadians(90);
    plane.position.y = 0.1;
    plane.backFaceCulling = false;
     
    
    // Shadows
    var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
    shadowGenerator.addShadowCaster(sphere);
    shadowGenerator.usePoissonSampling = true;


    // add a snappable grid system here -------------------
    let grid = new BABYLON.GridMaterial("grid", scene);
    grid.gridRatio = 0.1;
    grid.opacity = 1.0;
    grid.backFaceCulling = false;

    let ground = BABYLON.MeshBuilder.CreateGround("grid",{
        height: 10,
        width: 10,         
        subdivisions: 10,
        updatable: true
    }
    , scene, true);

    ground.material = grid;       
    plane.receiveShadows = true;
     

    // LOADER
    engine.displayLoadingUI();

    // GUI
    let advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI", true, scene);              
    let loadedGUI = await advancedTexture.parseFromURLAsync("https://raw.githubusercontent.com/sigma7zero/MapStar.github.io/main/guiTexture.json");
       
    // HELPERS      
    // Download the scene to the client's machine (Note: Web Safe)
    var objectUrl;

    function downloadSceneFile(filename, scene) {
        if(objectUrl) {
            window.URL.revokeObjectURL(objectUrl);
        }
    
        var serializedScene = BABYLON.SceneSerializer.Serialize(scene);
        
        var strMesh = JSON.stringify(serializedScene);
    
        if (filename.toLowerCase().lastIndexOf(".babylon") !== filename.length - 8 || filename.length < 9){
            filename += ".babylon";
        }
            
	    var blob = new Blob ( [ strMesh ], { type : "octet/stream" } );
       
        // turn blob into an object URL; saved as a member, so can be cleaned out later
        objectUrl = (window.webkitURL || window.URL).createObjectURL(blob);
    
        var link = window.document.createElement('a');
        link.href = objectUrl;
        link.download = filename;
        var click = document.createEvent("MouseEvents");
        click.initEvent("click", true, false);
        link.dispatchEvent(click);          
    }

    function serializedSceneToString(_scene){
        if (_scene == null) return 0;        
        var serializedScene = BABYLON.SceneSerializer.Serialize(scene);
	    var strScene = JSON.stringify(serializedScene);
        return strScene;
    }

    function saveTextAsFile(strToSave, fileNameToSaveAs, pathToFile){

        var textToWrite = strToSave;
        var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});    
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null)
        {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else
        {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }

        downloadLink.click();
    }

    //Stats etc
    var instrumentation = new BABYLON.SceneInstrumentation(scene);    
    var toggleStats = true;    
    if (toggleStats){
        instrumentation.captureFrameTime = true;
        instrumentation.captureActiveMeshesEvaluationTime = true;
        instrumentation.captureRenderTargetsRenderTime = true;
        instrumentation.captureFrameTime = true;
        instrumentation.captureRenderTime = true;
        instrumentation.captureInterFrameTime = true;
        instrumentation.captureParticlesRenderTime = true;
        instrumentation.captureSpritesRenderTime = true;
        instrumentation.capturePhysicsTime = true;
        instrumentation.captureAnimationsTime = true;
    }
    
   

    // Environment Window - map selection system ------------------------------------------------------------------
    let selectColor = "rgba(0, 255, 13, 255)";
    let envWindow = advancedTexture.getControlByName("envWindow");    
    const envRepo = "https://raw.githubusercontent.com/sigma7zero/MapStar/main/Environments/fileManifest.txt";
     
    function getText(url){
        //read text from url location 
        var request = new XMLHttpRequest();
        request.open('GET', url, false);
        request.send(null);
        return request.responseText;       
    }
       
    let envManifest = getText(envRepo);
    //console.log("MANIFEST: \n" + envManifest);
    
    let envArray = envManifest.split("\n");
    //console.log("ENVARRAY: " + envArray);

    let thumbNail = advancedTexture.getControlByName("ThumbNail");
    let envThumbnailStack = advancedTexture.getControlByName("EnvThumbnailStack");
    let envPreviewImage = advancedTexture.getControlByName("EnvPreviewImage");
    let envThumbnails = [];
    let envId = 0;    

    // Create an array of thumbnails and add gui control to the stack
    envArray.forEach(element =>{
        if (element.includes("_thumb") ){               
            
            envThumbnails.push(element);
            var newThumbNail = thumbNail.clone();

            // set parameters here
            newThumbNail.color = "black";          
            
            // create source link (string) to element (asset)
            newThumbNail.getDescendants()[1].source = envRepo.split("fileManifest.txt")[0] + element; 
            
            // give each thumbnail a unique name (id0 ... id17 etc)
            newThumbNail.getDescendants()[0].name = "env" + envId++;           

            envThumbnailStack.addControl(newThumbNail);
        }       
    });
   
    // HELPER FUNCTION gets the list of file names
    function getEnvFileNames(){
        var _names = [];
        var _index = 0;        
        envArray.forEach(element =>{
            if (element.includes("_thumb") == false){
                _names[_index++] = element.split(".")[0];
            }
        });
        return _names;
    };
    let envNames = getEnvFileNames();
    //console.log("envNames [] => \n" + envNames);


    // hide the first thumbnail, just use clones from this point
    envThumbnailStack.children[0].isVisible = false;
    envThumbnailStack.children[1].color = selectColor;

    let sizeOfStack = envThumbnailStack.children.length;   

    function resetEnvSelector(){
        for(var n = 0; n < sizeOfStack; n++){
            envThumbnailStack.children[n].color = 'black';
        };
    };


    let selectedEnvMap = envThumbnails[0].split("_")[0];
    let envLabelText = advancedTexture.getControlByName("EnvLabelText");
    let selectedEnvSrc = "https://raw.githubusercontent.com/sigma7zero/MapStar/main/Environments/Azure1.jpg";
    envLabelText.text = selectedEnvMap;
      
        
    for(let i=1; i < sizeOfStack; i++){         
        
        envThumbnailStack.children[i].onPointerUpObservable.add(function() {
            resetEnvSelector();                        
            console.log("BUTTON id was: " + i);         
            envThumbnailStack.children[i].color = selectColor;
            selectedEnvMap = envNames[i-1];
            envLabelText.text = selectedEnvMap;

            // show a preview of environment
            envPreviewImage.source = envThumbnailStack.children[i].getDescendants()[1].source; 
            console.log("envThumbnailStack[i] : \n" + envThumbnailStack.children[i].getDescendants()[1].source);
                        
            // select the full HDR texture source
            console.log("Full HDR file location: \n" + envRepo.split("fileManifest.txt")[0] + selectedEnvMap + ".jpg");
            selectedEnvSrc = envRepo.split("fileManifest.txt")[0] + selectedEnvMap + ".jpg"
        });
    };   
    

    //Asset tabs manager -------------------------------------------------------------------------------------------
    //Select tab buttons
    let tab_MapsButton = advancedTexture.getControlByName("tab_Maps");
    let tab_ModelsButton = advancedTexture.getControlByName("tab_Models");
    let tab_MaterialsButton = advancedTexture.getControlByName("tab_Materials");
    let tab_TexturesButton = advancedTexture.getControlByName("tab_Textures");
    let tab_SoundsButton = advancedTexture.getControlByName("tab_Sounds"); 

    //Red dot selection inicators
    let selectMarkerDotMaps = advancedTexture.getControlByName("selectMarkerDotMaps");
    let selectMarkerDotModels = advancedTexture.getControlByName("selectMarkerDotModels");
    let selectMarkerDotMaterials = advancedTexture.getControlByName("selectMarkerDotMaterials");
    let selectMarkerDotTextures = advancedTexture.getControlByName("selectMarkerDotTextures");
    let selectMarkerDotSounds = advancedTexture.getControlByName("selectMarkerDotSounds");
    
    //Red line selection indicators
    let selectMapMarkerLine = advancedTexture.getControlByName("MapMarker");
    let selectModelMarkerLine = advancedTexture.getControlByName("ModelMarker");
    let selectMaterialMarkerLine = advancedTexture.getControlByName("MaterialsMarker");
    let selectTextureMarkerLine = advancedTexture.getControlByName("TextureMarker");
    let selectSoundMarkerLine = advancedTexture.getControlByName("SoundMarker");
       
    function resetMapThumbnails(){
        mapsThumb_1.color = "black";
        mapsThumb_2.color = "black";
        mapsThumb_3.color = "black";
    }
   
    function resetMarkerDots(){
        selectMarkerDotMaps.isVisible = false;
        selectMarkerDotModels.isVisible = false;
        selectMarkerDotMaterials.isVisible = false;
        selectMarkerDotTextures.isVisible = false;
        selectMarkerDotSounds.isVisible = false;
    }

    function resetMarkerLines(){
        selectMapMarkerLine.isVisible = false;
        selectModelMarkerLine.isVisible = false;
        selectMaterialMarkerLine.isVisible = false;
        selectTextureMarkerLine.isVisible = false;
        selectSoundMarkerLine.isVisible = false;
    }   
    
    //Asset panel viewing modes
    let soundAssetsViewer = advancedTexture.getControlByName("ScrollViewerSounds");
    let textureAssetsViewer = advancedTexture.getControlByName("ScrollViewerTextures");
    let materialAssetsViewer = advancedTexture.getControlByName("ScrollViewerMaterials");
    let modelAssetsViewer = advancedTexture.getControlByName("ScrollViewerModels");
    let mapAssetsViewer = advancedTexture.getControlByName("ScrollViewerMaps");

    function resetAssetViewer(){
        soundAssetsViewer.isVisible = false;
        textureAssetsViewer.isVisible = false;
        materialAssetsViewer.isVisible = false;
        modelAssetsViewer.isVisible = false;
        mapAssetsViewer.isVisible = false;
    }

    let tab_selected = "Maps";
    console.log("START TAB: " + tab_selected);

    tab_MapsButton.onPointerUpObservable.add(function () {
        
        resetMarkerDots();
        resetMarkerLines();
        resetAssetViewer()
        tab_selected = "Maps";        
	    selectMarkerDotMaps.isVisible = true;
        selectMapMarkerLine.isVisible = true;
        mapAssetsViewer.isVisible = true;	    
        console.log("TAB SELECT: " + tab_selected);

    });

    tab_ModelsButton.onPointerUpObservable.add(function () {

        resetMarkerDots();
        resetMarkerLines();
        resetAssetViewer()
        tab_selected = "Models";	    
	    selectMarkerDotModels.isVisible = true;
        selectModelMarkerLine.isVisible = true;
        modelAssetsViewer.isVisible = true;
        console.log("TAB SELECT: " + tab_selected);
    });

    tab_MaterialsButton.onPointerUpObservable.add(function () {

        resetMarkerDots();
        resetMarkerLines();
        resetAssetViewer()
        tab_selected = "Materials";
	    selectMarkerDotMaterials.isVisible = true;
        selectMaterialMarkerLine.isVisible = true;
        materialAssetsViewer.isVisible = true;
        console.log("TAB SELECT: " + tab_selected);
    });

    tab_TexturesButton.onPointerUpObservable.add(function () {

        resetMarkerDots();
        resetMarkerLines();
        resetAssetViewer()
        tab_selected = "Textures";
	    selectMarkerDotTextures.isVisible = true;
        selectTextureMarkerLine.isVisible = true;
        textureAssetsViewer.isVisible = true;
        console.log("TAB SELECT: " + tab_selected);
    });

    tab_SoundsButton.onPointerUpObservable.add(function () {

        resetMarkerDots();
        resetMarkerLines();
        resetAssetViewer()
        tab_selected = "Sounds";
	    selectMarkerDotSounds.isVisible = true;
        selectSoundMarkerLine.isVisible = true;        
        soundAssetsViewer.isVisible = true;
        console.log("TAB SELECT: " + tab_selected);
    });
        
    let saveProjectWindow = advancedTexture.getControlByName("SaveWindow");
    saveProjectWindow.isVisible = false;

    //New Project window & operations ----------------------------------------------------------------
    let newButton = advancedTexture.getControlByName("ButtonNew");
    let newButtonLight = advancedTexture.getControlByName("illuminateNewButton");    
    let newProjectWindow = advancedTexture.getControlByName("NewWindow"); 
    let newProjectCancelButton = advancedTexture.getControlByName("cancelNewProject");
    let newProjectApplyButton = advancedTexture.getControlByName("applyNewProjectButton");    
    let newProjectNameInput = advancedTexture.getControlByName("ProjectNameInput");
    let newProjectWorkspaceInput = advancedTexture.getControlByName("ProjectWorkspace");
    let newProjectEditorRepoInput = advancedTexture.getControlByName("EditorRepoLink");    
    let newMapFileWindow = advancedTexture.getControlByName("CreateMapFile");
    let newMapBackButton = advancedTexture.getControlByName("backButtonNew");
    let newMapApplyButton = advancedTexture.getControlByName("applyDataButton"); 
    newProjectWindow.isVisible = false;
    newMapFileWindow.isVisible = false; 
    newProjectWorkspaceInput.isVisible = true;       
    newButtonLight.isVisible = newProjectWindow.isVisible;

    const projectTemplates = ["StartMap", "TableTop", "FirstPerson", "ThirdPerson", "OceanMap", "2DMap"];
    let selectedTemplate = 0;
    let StartMapButton = advancedTexture.getControlByName("StartMapButton");
    let TableTopMapButton = advancedTexture.getControlByName("TableTopMapButton");
    let FPSMapButton = advancedTexture.getControlByName("FPSMapButton");
    let ThirdPersonMapButton = advancedTexture.getControlByName("ThirdPersonMapButton");
    let OceanMapButton = advancedTexture.getControlByName("OceanMapButton");
    let twoDMapButton = advancedTexture.getControlByName("2DMapButton");
    let CarRaceMapButton = advancedTexture.getControlByName("CarRaceMapButton");

    function resetTemplates(){
        StartMapButton.color = "black";
        TableTopMapButton.color = "black";
        FPSMapButton.color = "black";
        ThirdPersonMapButton.color = "black";
        OceanMapButton.color = "black";
        twoDMapButton.color = "black";
        CarRaceMapButton.color = "black";
    }

    StartMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        StartMapButton.color = selectColor;
        selectedTemplate = 0;
    });

    TableTopMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        TableTopMapButton.color = selectColor;
        selectedTemplate = 1;
    });

    FPSMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        FPSMapButton.color = selectColor;
        selectedTemplate = 2;
    });

    ThirdPersonMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        ThirdPersonMapButton.color = selectColor;
        selectedTemplate = 3;
    });

    OceanMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        OceanMapButton.color = selectColor;
        selectedTemplate = 4;
    });

    twoDMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        twoDMapButton.color = selectColor;
        selectedTemplate = 5;
    });

    CarRaceMapButton.onPointerUpObservable.add(function () {
        resetTemplates();
        CarRaceMapButton.color = selectColor;
        selectedTemplate = 6;
    });

    newButton.onPointerUpObservable.add(function () {
        if (!newProjectWindow.isVisible) {
            newProjectWindow.isVisible = true;
            newButtonLight.isVisible = true;
        }
        else {
            newProjectWindow.isVisible = false;
            newButtonLight.isVisible = false;
        }
    });

    newButton.onPointerEnterObservable.add(function () {
        if (!newProjectWindow.isVisible) {
            newButtonLight.isVisible = true;
        }
    });

    newButton.onPointerOutObservable.add(function () {
        if (!newProjectWindow.isVisible) {
             newButtonLight.isVisible = false;
        }
    });

    newProjectCancelButton.onPointerUpObservable.add(function () {
        newProjectWindow.isVisible = false;
        newButtonLight.isVisible = false;
    });
    newProjectCancelButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("cancelNewButtonLight").isVisible = true });    
    newProjectCancelButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("cancelNewButtonLight").isVisible = false });


    newProjectApplyButton.onPointerUpObservable.add(function () {
        if (!newMapFileWindow.isVisible){newMapFileWindow.isVisible = true;}        
        
    });	  
    newProjectApplyButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("applyNewButtonLight").isVisible = true });    
    newProjectApplyButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("applyNewButtonLight").isVisible = false });


    newMapBackButton.onPointerUpObservable.add(function () {
        if (newMapFileWindow.isVisible){newMapFileWindow.isVisible = false;}
    });
    newMapBackButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateBackButton").isVisible = true });    
    newMapBackButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateBackButton").isVisible = false }); 
    
    //Helper
    async function SaveTheFile(_data, _name) {        
        const options = {
            _preferedMethods: ['native', 'constructing-blob'],            
            types: [
            {
                description: 'MapStar Files',
                accept: {
                'text/plain': ['.map'],
                },
            },
            ],
            startIn: "desktop",
            suggestedName:  _name      
        
        };

	try {    
        const handle = await window.showSaveFilePicker(options); 
        const writable = await handle.createWritable();
        await writable.write(_data);
        await writable.close();
	}
	catch(e){
	    // If Browser doesn't support showSaveFilePicker(options), defer to FileSaver.js method - put file in Download folder
            var blob = new Blob([_data], {type: "text/plain;charset=utf-8"});
            saveAs(blob, _name);
            console.log("CATCH ENTERED ... Browser throws an error");
	}
     };		
     
    newMapApplyButton.onPointerUpObservable.add(function () {
        if (newMapFileWindow.isVisible){
            newMapFileWindow.isVisible = false;
            newProjectWindow.isVisible = false;
	        newButtonLight.isVisible = false;
		
            // Save map file to client HD
            var projectData = 
                "MAP STAR version 0.1.1\n" +
                "----------------------\n"+
                "Project Name      : " + newProjectNameInput.text + "\n" +
                "Project Workspace : " + newProjectWorkspaceInput.text + "\n" +
                "Project Template  : " + projectTemplates[selectedTemplate] + "\n" +
                "Editor Repository : " + newProjectEditorRepoInput.text + "\n" +
                "User Repository 1 : " + "\n" +
                "User Repository 2 : " + "\n" +
                "User Repository 3 : " + "\n" +
                "User Repository 4 : " + "\n" +
                "User Repository 5 : " + "\n" +
                "User Repository 6 : " + "\n" ;              
            
            SaveTheFile(projectData, newProjectNameInput.text);
          	
        }
    });
    newMapApplyButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("applyNewMapLightModal").isVisible = true });    
    newMapApplyButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("applyNewMapLightModal").isVisible = false }); 
    
    // Open existing project from file on users drive ------------------------------------------------------------------------------------------
    let openProjectWindow = advancedTexture.getControlByName("OpenWindow");    
    let openButton = advancedTexture.getControlByName("ButtonOpen");    
    let cancelOpenButton = advancedTexture.getControlByName("cancelOpenButton");	    
    openProjectWindow.isVisible = false;
	    
    openButton.onPointerUpObservable.add(function () { 
         if (!openProjectWindow.isVisible) {
            openProjectWindow.isVisible = true;
            advancedTexture.getControlByName("illuminateOpenButton").isVisible = true
        }
        else {
            openProjectWindow.isVisible = false;
            advancedTexture.getControlByName("illuminateOpenButton").isVisible = false
        }        
    });
        
    openButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateOpenButton").isVisible = true });
    openButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateOpenButton").isVisible = false });
	    
    let saveButton = advancedTexture.getControlByName("ButtonSave");
    saveButton.onPointerUpObservable.add(function () { 
        if (!saveProjectWindow.isVisible) {
            saveProjectWindow.isVisible = true;
            advancedTexture.getControlByName("illuminateSaveButton").isVisible = true
        }
        else {
            saveProjectWindow.isVisible = false;
            advancedTexture.getControlByName("illuminateSaveButton").isVisible = false
        }                
    });
        
    saveButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateSaveButton").isVisible = true });
    saveButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateSaveButton").isVisible = false });

    let exportButton = advancedTexture.getControlByName("ButtonExport");
    exportButton.onPointerUpObservable.add(function () { alert("ButtonExport Pressed!...."); });
    exportButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateExportButton").isVisible = true });
    exportButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateExportButton").isVisible = false });

    
	// Environment (Sky) selection window ----------------------------------------------------------------------------------------------------   
    let envButton = advancedTexture.getControlByName("envButton");
    let envButtonLight = advancedTexture.getControlByName("envButtonLight");           
    
    envWindow.isVisible = false;        
    envButtonLight.isVisible = envWindow.isVisible;
    
    envButton.onPointerUpObservable.add(function () {
        if (!envWindow.isVisible) {
            envWindow.isVisible = true;
            envButtonLight.isVisible = true;
        }
        else {
            envWindow.isVisible = false;
            envButtonLight.isVisible = false;
        }
    });

    envButton.onPointerEnterObservable.add(function () {
        if (!envWindow.isVisible) {
            envButtonLight.isVisible = true;
        }
    });

    envButton.onPointerOutObservable.add(function () {
        if (!envWindow.isVisible) {
            envButtonLight.isVisible = false;
        }
    });
       

    let cancelEnvButton = advancedTexture.getControlByName("cancelEnvButton");
    cancelEnvButton.onPointerUpObservable.add(function () {       
	envWindow.isVisible = false;
	envButtonLight.isVisible = false;        
	console.log("EVENT => cancelEnvButton was pressed ...!");
    });
    cancelEnvButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("cancelEnvButtonLight").isVisible = true });    
    cancelEnvButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("cancelEnvButtonLight").isVisible = false });


    let applyEnvButton = advancedTexture.getControlByName("applyEnvButton");
    let applyEnvButtonLight = advancedTexture.getControlByName("applyEnvButtonLight");

    applyEnvButton.onPointerUpObservable.add(function () {
        
        //Set this selection as the environment map background         
        setEnvMap(
        selectedEnvSrc,
        skyMat,
        true,
        false,
        skySphere
    );

        if (!envWindow.isVisible) {
            envWindow.isVisible = true;
            envButtonLight.isVisible = true;
        }
        else {
            envWindow.isVisible = false;
            envButtonLight.isVisible = false;
        }
               
    });

    applyEnvButton.onPointerEnterObservable.add(function () {applyEnvButtonLight.isVisible = true;});
    applyEnvButton.onPointerOutObservable.add(function () {applyEnvButtonLight.isVisible = false;});         
       
    //-------------------------------------------------------------------------------------------------

    let cameraEnvButton = advancedTexture.getControlByName("cameraEnvButton");
    let cameraEnvButtonLight = advancedTexture.getControlByName("cameraEnvButtonLight");
    
    cameraEnvButton.onPointerUpObservable.add(function () { alert("cameraEnvButton Pressed!...."); });
    
    cameraEnvButton.onPointerEnterObservable.add(function () {       
            cameraEnvButtonLight.isVisible = true;        
    });

    cameraEnvButton.onPointerOutObservable.add(function () {       
            cameraEnvButtonLight.isVisible = false;        
    });

    let lightingEnvButton = advancedTexture.getControlByName("lightingEnvButton");
    let lightingEnvButtonLight = advancedTexture.getControlByName("lightingEnvButtonLight");
    
    lightingEnvButton.onPointerUpObservable.add(function () { alert("lightingEnvButton Pressed!...."); });
    
    lightingEnvButton.onPointerEnterObservable.add(function () {       
            lightingEnvButtonLight.isVisible = true;        
    });

    lightingEnvButton.onPointerOutObservable.add(function () {       
            lightingEnvButtonLight.isVisible = false;        
    });

    // Scene cameras -------------------------------------------------------------------
    let camToggle = false;
    let sm_cameraButton = advancedTexture.getControlByName("sm_cameraButton");
    let sm_cameraButtonLight = advancedTexture.getControlByName("sm_cameraButtonLight");
    let sm_cameraButton_cameraImage = advancedTexture.getControlByName("ImageCamera");
    let sm_cameraButton_gamePadImage = advancedTexture.getControlByName("ImageGamePad");
    let textblockCamType = advancedTexture.getControlByName("TextblockCamType");
    
    // Start mode is Arc Rotate Camera - (GamePad icon visible)
    textblockCamType.text = "Arc Rotate Camera";
    sm_cameraButton_cameraImage.isVisible = false;
    sm_cameraButton_gamePadImage.isVisible = true;    
    scene.activeCamera = arcRotateCamera;
    scene.activeCamera.attachControl(canvas, true);   
    sm_cameraButtonLight.isVisible = false;

    sm_cameraButton.onPointerUpObservable.add(function () {         
        
        if (!camToggle) {
            camToggle = true;   
            
            // Change to First Person Camera Mode - (Camera Icon Visible)
            sm_cameraButton_cameraImage.isVisible = true;
            sm_cameraButton_gamePadImage.isVisible = false;           
            textblockCamType.text = "First Person Camera";
            scene.activeCamera.detachControl(canvas);            
            scene.activeCamera = gameCamera;
            scene.activeCamera.attachControl(canvas, true);

        }
        else {
            camToggle = false;

             // Change to Arc Rotate Camera Mode - (GamePad icon visible)
            sm_cameraButton_cameraImage.isVisible = false;
            sm_cameraButton_gamePadImage.isVisible = true;            
            scene.activeCamera.detachControl(canvas);
            textblockCamType.text = "Arc Rotate Camera";           
            scene.activeCamera = arcRotateCamera;
            scene.activeCamera.attachControl(canvas, true);
        }       

    });

    sm_cameraButton.onPointerEnterObservable.add(function () {
        sm_cameraButtonLight.isVisible = true;
    });

    sm_cameraButton.onPointerOutObservable.add(function () {
        sm_cameraButtonLight.isVisible = false;
    });
    
    // Cross platform fullscreen toggle
    const canvasParent = document.getElementById("canvasZone");
    canvasParent.style.position = "relative";
    let fullScreenToggle = false;
    let smFullscreenButton = advancedTexture.getControlByName("smFullscreenButton");
    let smFullScreenButtonLight = advancedTexture.getControlByName("smFullScreenButtonLight");
    let smFullScreenButtonMaxIcon = advancedTexture.getControlByName("ImageMaxScreen");
    let smFullScreenButtonMinIcon = advancedTexture.getControlByName("ImageMinScreen");
    let CreatePanelEndPoint = advancedTexture.getControlByName("CreatePanelEndPoint");    
        
    smFullScreenButtonLight.isVisible = false;
    smFullScreenButtonMaxIcon.isVisible = true;
    smFullScreenButtonMinIcon.isVisible = false;     
        

    smFullscreenButton.onPointerUpObservable.add(function () {
        
        if (!fullScreenToggle) {
            canvasParent.requestFullscreen();
            smFullScreenButtonMaxIcon.isVisible = false;
            smFullScreenButtonMinIcon.isVisible = true;
            fullScreenToggle = true;

            // Turn off slider in fullscreen mode
            CreatePanelEndPoint.isVisible = false;
        }
        else{
            document.exitFullscreen();
            smFullScreenButtonMaxIcon.isVisible = true;
            smFullScreenButtonMinIcon.isVisible = false;
            fullScreenToggle = false;

            // Turn on slider in window mode
            CreatePanelEndPoint.isVisible = true;
        }       
    });

    
    // If the user presses down the Esc key on the physical keyboard, gui must reflect the change
    function fullscreenChangedHandler(evt){
        if (document.fullscreenElement){
            console.log("Entered Fullscreen Mode");
        }
        else{
            console.log("Leaving Fullscreen Mode");
            smFullScreenButtonMaxIcon.isVisible = true;
            smFullScreenButtonMinIcon.isVisible = false;
            fullScreenToggle = false;

            // Turn on slider in window mode
            CreatePanelEndPoint.isVisible = true;
        }
    }
    document.addEventListener("fullscreenchange", fullscreenChangedHandler);

    smFullscreenButton.onPointerEnterObservable.add(function () {
        smFullScreenButtonLight.isVisible = true;
    });

    smFullscreenButton.onPointerOutObservable.add(function () {
        smFullScreenButtonLight.isVisible = false;
    });

    let terrainButton = advancedTexture.getControlByName("ButtonTerrain");
    terrainButton.onPointerUpObservable.add(function () { alert("ButtonTerrain Pressed!...."); });
    terrainButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateTerrainButton").isVisible = true });
    terrainButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateTerrainButton").isVisible = false });

    let physicsButton = advancedTexture.getControlByName("ButtonPhysics");
    physicsButton.onPointerUpObservable.add(function () { alert("Physics Button Pressed!...."); });
    physicsButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminatePhysicsButton").isVisible = true });
    physicsButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminatePhysicsButton").isVisible = false });

    let buildingsButton = advancedTexture.getControlByName("ButtonBuildings");
    buildingsButton.onPointerUpObservable.add(function () { alert("ButtonBuildings Pressed!...."); });
    buildingsButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateBuildingsButton").isVisible = true });
    buildingsButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateBuildingsButton").isVisible = false });

    let vegetationButton = advancedTexture.getControlByName("ButtonVegetation");
    vegetationButton.onPointerUpObservable.add(function () { alert("ButtonVegetation Pressed!...."); });
    vegetationButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateVegetationButton").isVisible = true });
    vegetationButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateVegetationButton").isVisible = false });

    let charactersButton = advancedTexture.getControlByName("ButtonCharacters");
    charactersButton.onPointerUpObservable.add(function () { alert("ButtonCharacters Pressed!...."); });
    charactersButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateCharactersButton").isVisible = true });
    charactersButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateCharactersButton").isVisible = false });

    let logicButton = advancedTexture.getControlByName("ButtonLogic");
    logicButton.onPointerUpObservable.add(function () { alert("ButtonLogic Pressed!...."); });
    logicButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateLogicButton").isVisible = true });
    logicButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateLogicButton").isVisible = false });

    let audioButton = advancedTexture.getControlByName("ButtonAudio");
    audioButton.onPointerUpObservable.add(function () { alert("ButtonAudio Pressed!...."); });
    audioButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateAudioButton").isVisible = true });
    audioButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateAudioButton").isVisible = false });

    let hudButton = advancedTexture.getControlByName("ButtonHUD");
    hudButton.onPointerUpObservable.add(function () { alert("ButtonHUD Pressed!...."); });
    hudButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateHUDButton").isVisible = true });
    hudButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateHUDButton").isVisible = false });

    let createButton = advancedTexture.getControlByName("createButton");
    let createButtonLight = advancedTexture.getControlByName("createButtonLight");
    let createPanel = advancedTexture.getControlByName("createPanel");
    
    // Setup small reset button in sync with the main Create Panel
    let sm_resetButton = advancedTexture.getControlByName("sm_resetButton");
    let sm_resetButtonLight = advancedTexture.getControlByName("sm_resetButtonLight");
    let sm_resetCloseIcon = advancedTexture.getControlByName("Image_Close");
    let sm_resetOpenIcon = advancedTexture.getControlByName("Image_Open");

    let toggleCreatePanel = true;    
        
    createButtonLight.isVisible = createPanel.isVisible;   

    createButton.onPointerUpObservable.add(function () {
        if (!createPanel.isVisible) {
            createPanel.isVisible = true;
            toggleCreatePanel = true;
            createButtonLight.isVisible = true;
            sm_resetCloseIcon.isVisible = true;
            sm_resetOpenIcon.isVisible = false;
            sm_resetButtonLight.isVisible = true;
        }
        else {
            createPanel.isVisible = false;
            toggleCreatePanel = false;
            createButtonLight.isVisible = false;
            sm_resetCloseIcon.isVisible = false;
            sm_resetOpenIcon.isVisible = true;
            sm_resetButtonLight.isVisible = false;
        }
    });

    createButton.onPointerEnterObservable.add(function () {
        if (!createPanel.isVisible.isVisible) {
            createButtonLight.isVisible = true;
        }
    });

    createButton.onPointerOutObservable.add(function () {
        if (!createPanel.isVisible) {
            createButtonLight.isVisible = false;
        }
    });

    sm_resetButton.onPointerUpObservable.add(function () {
        if (!toggleCreatePanel) {
            createPanel.isVisible = true;
            toggleCreatePanel = true;
            sm_resetButtonLight.isVisible = true;
            createButtonLight.isVisible = true;
            sm_resetCloseIcon.isVisible = true;
            sm_resetOpenIcon.isVisible = false;
        }
        else {
            createPanel.isVisible = false;
            toggleCreatePanel = false;
            sm_resetButtonLight.isVisible = false;
            createButtonLight.isVisible = false;
            sm_resetCloseIcon.isVisible = false;
            sm_resetOpenIcon.isVisible = true;
        }
    });

    sm_resetButton.onPointerEnterObservable.add(function () {
        sm_resetButtonLight.isVisible = true;
    });

    sm_resetButton.onPointerOutObservable.add(function () {
        sm_resetButtonLight.isVisible = false;
    });


    let assetsButton = advancedTexture.getControlByName("assetsButton");
    let assetsButtonLight = advancedTexture.getControlByName("assetsButtonLight");
    let assetsPanel = advancedTexture.getControlByName("assetsPanel");
    let tabContainer = advancedTexture.getControlByName("Tab Container");
    
    assetsPanel.isVisible = true;
    tabContainer.isVisible = true;

    assetsButtonLight.isVisible = assetsPanel.isVisible;
    assetsButton.onPointerUpObservable.add(function () {
        if (!assetsPanel.isVisible) {
            assetsPanel.isVisible = true;
            tabContainer.isVisible = true;
        }
        else {
            assetsPanel.isVisible = false;
            tabContainer.isVisible = false;
            assetsButtonLight.isVisible = false;
        }
    });

    assetsButton.onPointerEnterObservable.add(function () {
        if (!assetsPanel.isVisible) {
            assetsButtonLight.isVisible = true;
        }
    });

    assetsButton.onPointerOutObservable.add(function () {
        if (!assetsPanel.isVisible) {
            assetsButtonLight.isVisible = false;
        }
    });

    let multiplayerButton = advancedTexture.getControlByName("ButtonMultiplayer");
    multiplayerButton.onPointerUpObservable.add(function () { alert("ButtonMultiplayer Pressed!...."); });
    multiplayerButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateMultiplayerButton").isVisible = true });
    multiplayerButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateMultiplayerButton").isVisible = false });




    // Settings Window ----------------------------------------------------------------------------------------------------
    let settingsWindow = advancedTexture.getControlByName("Settings");
    let settingsButton = advancedTexture.getControlByName("ButtonSettings");
    settingsWindow.isVisible = false;    
    
    settingsButton.onPointerUpObservable.add(function () { 
        if (!settingsWindow.isVisible) {
            settingsWindow.isVisible = true;
            advancedTexture.getControlByName("illuminateSettingsButton").isVisible = true;
        }
        else {
            settingsWindow.isVisible = false;
            advancedTexture.getControlByName("illuminateSettingsButton").isVisible = false;
        }
    });

    settingsButton.onPointerEnterObservable.add(function () { 
        if (!settingsWindow.isVisible) {
            advancedTexture.getControlByName("illuminateSettingsButton").isVisible = true;
        }
    });    
    
    settingsButton.onPointerOutObservable.add(function () { 
        if (!settingsWindow.isVisible) {
            advancedTexture.getControlByName("illuminateSettingsButton").isVisible = false;
        }        
    });
    
    let applySettingsButton = advancedTexture.getControlByName("applySettingsButton");

    applySettingsButton.onPointerUpObservable.add(function () {

        //Save settings to the map file          
        settingsWindow.isVisible = false;
        advancedTexture.getControlByName("illuminateSettingsButton").isVisible = false;

    });

    applySettingsButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("applySettingsButtonLight").isVisible = true });    
    applySettingsButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("applySettingsButtonLight").isVisible = false });

    let cancelSettingsButton = advancedTexture.getControlByName("cancelSettingsButton");    
    
    cancelSettingsButton.onPointerUpObservable.add(function () {       
	settingsWindow.isVisible = false; 
    advancedTexture.getControlByName("illuminateSettingsButton").isVisible = false;        
	console.log("EVENT => cancelSettings Button was pressed ...!");
    });

    cancelSettingsButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("cancelSettingsButtonLight").isVisible = true });    
    cancelSettingsButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("cancelSettingsButtonLight").isVisible = false });

    let ShowGridCheckbox = advancedTexture.getControlByName("ShowGridCheckbox");
    ShowGridCheckbox.checked = ground.isVisible;
    ShowGridCheckbox.onPointerUpObservable.add(function () {
        
        if(ShowGridCheckbox.checked) { 
            ShowGridCheckbox.checked = false;
            ground.isVisible = false;
        }else
        {
            ShowGridCheckbox.checked = true;
            ground.isVisible = true;
        }  
    });  
    
    let GridSizeSlider = advancedTexture.getControlByName("GridSizeSlider");
    let GridSizeOutputLabel = advancedTexture.getControlByName("GridSizeOutputLabel");
    GridSizeOutputLabel.text = 10;
    GridSizeSlider.minimum = 0;
    GridSizeSlider.maximum = 50;
    GridSizeSlider.value = 10;
    GridSizeSlider.onValueChangedObservable.add(function(value) {
        GridSizeOutputLabel.text = Math.round(value);        
        ground.scaling.x = Math.round(value);
        ground.scaling.y = Math.round(value);
        ground.scaling.z = Math.round(value);

    });

    let GridOpacitySlider = advancedTexture.getControlByName("GridOpacitySlider");
    let GridOpacityOutputLabel = advancedTexture.getControlByName("GridOpacityOutputLabel");

    GridOpacitySlider.onValueChangedObservable.add(function(value) {
        GridOpacityOutputLabel.text = value.toFixed(2); 
        grid.opacity = value.toFixed(2);
    });

    let GridRezSlider = advancedTexture.getControlByName("GridRezSlider");
    let GridRezOutputLabel = advancedTexture.getControlByName("GridRezOutputLabel");

    GridRezSlider.onValueChangedObservable.add(function(value) {
        GridRezOutputLabel.text = value.toFixed(4);
        grid.gridRatio = value;
    });

    let GridColorPicker = advancedTexture.getControlByName("GridColorPicker");

    GridColorPicker.onValueChangedObservable.add(function(value) {
        grid.lineColor = value;
    });

    // Pickable objects --------------------------------------------------------------
    let TextblockMain = advancedTexture.getControlByName("TextblockMain");    
    TextblockMain.text = "CTRL + Click on objects";
    //TextblockMain.color = "#50B1FFFF";
    TextblockMain.color = "white";

    //Highlight picked objects
    let highLighter = new BABYLON.HighlightLayer("highLightLayer1", scene); 
    
    const highlightColor = new BABYLON.Color3(0, 255, 13);
    
    let selectedMesh = null;

    let previousSelections = [];    

    let notSelectable = ['sky', 'grid'];    

    scene.onPointerObservable.add((pointerInfo) => {
        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN){
        
            //Only select objects if the CTRL key is held down
            if (event.ctrlKey){
                selectedMesh = pointerInfo.pickInfo.pickedMesh;                
                var skipSelection = false;

                //Some objects can't be selected (highlighted)
                notSelectable.forEach(element => {
                    if (element == selectedMesh.name) {
                    console.log(element + " is not selectable");                    
                    skipSelection = true;
                    }
                });
                
                // Don't highlight object if it's listed as NOT SELECTABLE 
                if (!skipSelection){                                   

                    if (selectedMesh){

                        //If it is already selected? De-select and remove from the array
                        //Search array
                        var index = previousSelections.indexOf(selectedMesh);
                        if (index != -1){                        
                            highLighter.removeMesh(selectedMesh);                            
                            //selectedMesh = previousSelections[index - 1];
                            //selectedMesh = previousSelections[index];
                            previousSelections.splice(index, 1);
                            var _length = previousSelections.length;
                            if (_length){
                                TextblockMain.text = "Selected Mesh: " + previousSelections[previousSelections.length - 1].name;
                            }
                            else{
                                TextblockMain.text = "Selected Mesh: None";
                            }
                        }
                        else{
                            highLighter.addMesh(selectedMesh, highlightColor);
                            previousSelections.push(selectedMesh);
                            TextblockMain.text = "Selected Mesh: " + selectedMesh.name;
                        }                        
                    }
                }    
            }         
        }          
    });
    

    scene.onKeyboardObservable.add((kbInfo) => {
        if (kbInfo.type == BABYLON.KeyboardEventTypes.KEYDOWN){
            if (kbInfo.event.key == "Enter"){
                console.log("Contents of selected Meshes Array : \n");
                previousSelections.forEach(element => {
                    console.log(element + "\n");
                })
            }
        }
    });



    //---------------------------------------------------------------------------------------------------------------------------------------------------
    let playButton = advancedTexture.getControlByName("ButtonPlay");
    playButton.onPointerUpObservable.add(function () { alert("ButtonPlay Pressed!...."); });
    playButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminatePlayButton").isVisible = true });
    playButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminatePlayButton").isVisible = false });

    let helpButton = advancedTexture.getControlByName("ButtonHelp");
    helpButton.onPointerUpObservable.add(function () { alert("ButtonHelp Pressed!...."); });
    helpButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateHelpButton").isVisible = true });
    helpButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateHelpButton").isVisible = false });

    
    let aboutWindow = advancedTexture.getControlByName("AboutWindow");
    let aboutButton = advancedTexture.getControlByName("ButtonAbout");

    let aboutWinOKButton = advancedTexture.getControlByName("AboutWinOKButton");

    let aboutWinOKButtonLight = advancedTexture.getControlByName("AboutWinOKButtonLight");

    let illuminateAboutButton = advancedTexture.getControlByName("illuminateAboutButton");
    
    illuminateAboutButton.isVisible = aboutWindow.isVisible;

    aboutButton.onPointerUpObservable.add(function () {
        if (!aboutWindow.isVisible) {
            aboutWindow.isVisible = true;
            illuminateAboutButton.isVisible = true;
        }
        else {
            aboutWindow.isVisible = false;
            illuminateAboutButton.isVisible = false;
        }
    });

    aboutButton.onPointerEnterObservable.add(function () {
        if (!aboutWindow.isVisible) {
            illuminateAboutButton.isVisible = true;
        }
    });

    aboutButton.onPointerOutObservable.add(function () {
        if (!aboutWindow.isVisible) {
            illuminateAboutButton.isVisible = false;
        }
    });




    aboutWinOKButton.onPointerUpObservable.add(function () {
        if (!aboutWindow.isVisible) {
            aboutWindow.isVisible = true;
            aboutWinOKButtonLight.isVisible = true;
        }
        else {
            aboutWindow.isVisible = false;
            aboutWinOKButtonLight.isVisible = false;
            illuminateAboutButton.isVisible = false;
        }
    });

    aboutWinOKButton.onPointerEnterObservable.add(function () {
        //if (!aboutWindow.isVisible) {
            aboutWinOKButtonLight.isVisible = true;
        //}
    });

    aboutWinOKButton.onPointerOutObservable.add(function () {
        //if (!aboutWindow.isVisible) {
            aboutWinOKButtonLight.isVisible = false;            
        //}
    });



    let donateButton = advancedTexture.getControlByName("ButtonDonate");
    donateButton.onPointerUpObservable.add(function () { alert("ButtonDonate Pressed!...."); });
    donateButton.onPointerEnterObservable.add(function () { advancedTexture.getControlByName("illuminateDonateButton").isVisible = true });
    donateButton.onPointerOutObservable.add(function () { advancedTexture.getControlByName("illuminateDonateButton").isVisible = false });

    // Get FPS and other stats
    var textblockFPS = advancedTexture.getControlByName("TextblockFPS");
    var textblockDrawCalls = advancedTexture.getControlByName("TextblockDrawCalls");
    var textblockFaces = advancedTexture.getControlByName("TextblockFaces");
    var textblockVerts = advancedTexture.getControlByName("TextblockVerts");
    var textblockMeshes = advancedTexture.getControlByName("TextblockMeshes");
        
    scene.registerAfterRender(() => {
        textblockFPS.text = " " + Math.round(scene.getEngine().getFps());        
        textblockDrawCalls.text = instrumentation.drawCallsCounter.current;
        textblockFaces.text =  scene.getActiveIndices() / 3;
        textblockVerts.text =  scene.getTotalVertices();
        textblockMeshes.text = scene.getActiveMeshes().length;
    });
    
    //Hide Loader
    engine.hideLoadingUI();
    
    return scene;
};
    

window.initFunction = async function() {                    
                    
    var asyncEngineCreation = async function() {
        try { return createDefaultEngine();} 
        catch(e) {
            console.log("the available createEngine function failed. Creating the default engine instead");
            return createDefaultEngine();
            }
        }

        window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        

        startRenderLoop(engine, canvas);
        window.scene = createScene();
    };        
            
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
    });
   
        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
        </script>
    </body>
</html>
